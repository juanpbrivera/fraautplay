/**
 * üîç Logger.ts
 * 
 * Sistema de logging centralizado del framework.
 * Piensa en el logger como una "caja negra" de un avi√≥n - registra TODO lo que pasa.
 * 
 * ¬øPor qu√© es importante el logging?
 * - Debugging: Ver qu√© est√° pasando cuando algo falla
 * - Auditor√≠a: Registro de todas las acciones
 * - Monitoreo: Detectar problemas en producci√≥n
 * - An√°lisis: Entender el comportamiento del sistema
 * 
 * Usamos Pino porque es:
 * - MUY r√°pido (no impacta el rendimiento)
 * - Estructurado (JSON logs)
 * - Flexible (m√∫ltiples destinos)
 */

import pino, { Logger as PinoLogger, LoggerOptions } from 'pino';
import pinoPretty from 'pino-pretty';
import * as fs from 'fs';
import * as path from 'path';
import { LogLevel, FrameworkError, ErrorCode } from '../../types/FrameworkTypes';
import { ConfigManager } from '../config/ConfigManager';

/**
 * üìä Contexto adicional para logs
 * Permite agregar informaci√≥n extra a cada log
 */
export interface LogContext {
  sessionId?: string;      // ID de la sesi√≥n actual
  testName?: string;       // Nombre del test ejecut√°ndose
  step?: string;           // Paso actual
  browser?: string;        // Navegador usado
  page?: string;           // P√°gina actual
  element?: string;        // Elemento involucrado
  action?: string;         // Acci√≥n ejecutada
  duration?: number;       // Duraci√≥n en ms
  error?: Error;           // Error si hubo
  screenshot?: string;     // Path del screenshot
  metadata?: Record<string, any>; // Datos adicionales
}

/**
 * üéØ Clase Logger - Maneja todo el logging del framework
 */
export class Logger {
  private pinoLogger: PinoLogger;
  private context: LogContext = {};
  private startTime?: Date;
  private config: any;
  
  /**
   * Constructor del Logger
   * @param name - Nombre del logger (ej: 'BrowserFactory', 'ElementManager')
   * @param context - Contexto inicial
   */
  constructor(name: string, context?: LogContext) {
    const configManager = ConfigManager.getInstance();
    this.config = configManager.get('logging');
    
    // Configurar opciones de Pino
    const options: LoggerOptions = {
      name,
      level: this.config.level || 'info',
      
      // Agregar informaci√≥n base a todos los logs
      base: {
        framework: 'web-automation-framework',
        environment: configManager.get('environment.name'),
        pid: process.pid,
        hostname: process.env.HOSTNAME || 'localhost'
      },
      
      // Formato de timestamp
      timestamp: this.config.timestamp ? pino.stdTimeFunctions.isoTime : false,
      
      // Serializers personalizados para objetos especiales
      serializers: {
        error: this.errorSerializer,
        req: this.requestSerializer,
        res: this.responseSerializer
      },
      
      // Hooks para procesar logs
      hooks: {
        logMethod(inputArgs: any[], method: any) {
          // Agregar contexto a cada log
          if (inputArgs.length >= 2 && typeof inputArgs[1] === 'object') {
            inputArgs[1] = { ...context, ...inputArgs[1] };
          }
          return method.apply(this, inputArgs);
        }
      }
    };
    
    // Determinar destino del log
    const destinations = [];
    
    // 1Ô∏è‚É£ Consola con formato pretty
    if (this.config.console) {
      const prettyOptions = {
        colorize: this.config.colorize,
        translateTime: 'SYS:standard',
        ignore: 'pid,hostname',
        messageFormat: '{msg}',
        singleLine: false,
        
        // Colores personalizados por nivel
        customColors: 'err:red,warn:yellow,info:green,debug:blue',
        
        // Formato personalizado para diferentes niveles
        customLevels: {
          trace: 10,
          debug: 20,
          info: 30,
          warn: 40,
          error: 50,
          fatal: 60
        },
        
        // Iconos para cada nivel (m√°s visual)
        customPrettifiers: {
          level: (logLevel: string) => {
            const icons: Record<string, string> = {
              trace: 'üîç',
              debug: 'üêõ',
              info: '‚úÖ',
              warn: '‚ö†Ô∏è',
              error: '‚ùå',
              fatal: 'üíÄ'
            };
            return `${icons[logLevel] || 'üìù'} ${logLevel.toUpperCase()}`;
          }
        }
      };
      
      if (this.config.pretty) {
        destinations.push(pinoPretty(prettyOptions));
      } else {
        destinations.push(pino.destination({ sync: false }));
      }
    }
    
    // 2Ô∏è‚É£ Archivo de log
    if (this.config.file && this.config.filePath) {
      const logDir = path.dirname(this.config.filePath);
      if (!fs.existsSync(logDir)) {
        fs.mkdirSync(logDir, { recursive: true });
      }
      
      destinations.push(
        pino.destination({
          dest: this.config.filePath,
          sync: false,
          mkdir: true
        })
      );
    }
    
    // Crear logger con m√∫ltiples destinos
    if (destinations.length > 1) {
      this.pinoLogger = pino(options, pino.multistream(destinations));
    } else if (destinations.length === 1) {
      this.pinoLogger = pino(options, destinations[0]);
    } else {
      // Si no hay destinos configurados, usar consola por defecto
      this.pinoLogger = pino(options);
    }
    
    // Establecer contexto inicial
    if (context) {
      this.setContext(context);
    }
  }
  
  /**
   * üîÑ Establecer contexto para futuros logs
   */
  public setContext(context: LogContext): void {
    this.context = { ...this.context, ...context };
  }
  
  /**
   * üîÑ Limpiar contexto
   */
  public clearContext(): void {
    this.context = {};
  }
  
  /**
   * ‚è±Ô∏è Iniciar medici√≥n de tiempo
   */
  public startTimer(): void {
    this.startTime = new Date();
  }
  
  /**
   * ‚è±Ô∏è Detener medici√≥n y obtener duraci√≥n
   */
  public stopTimer(): number {
    if (!this.startTime) return 0;
    const duration = new Date().getTime() - this.startTime.getTime();
    this.startTime = undefined;
    return duration;
  }
  
  // üìä M√©todos de logging por nivel
  
  /**
   * üîç TRACE: Informaci√≥n s√∫per detallada (debugging profundo)
   */
  public trace(message: string, data?: any): void {
    this.log('trace', message, data);
  }
  
  /**
   * üêõ DEBUG: Informaci√≥n de debugging
   */
  public debug(message: string, data?: any): void {
    this.log('debug', message, data);
  }
  
  /**
   * ‚úÖ INFO: Informaci√≥n general del flujo
   */
  public info(message: string, data?: any): void {
    this.log('info', message, data);
  }
  
  /**
   * ‚ö†Ô∏è WARN: Advertencias (algo raro pero no cr√≠tico)
   */
  public warn(message: string, data?: any): void {
    this.log('warn', message, data);
  }
  
  /**
   * ‚ùå ERROR: Errores recuperables
   */
  public error(message: string, error?: Error | any, data?: any): void {
    const logData = {
      ...data,
      error: error ? this.errorSerializer(error) : undefined
    };
    this.log('error', message, logData);
  }
  
  /**
   * üíÄ FATAL: Errores cr√≠ticos (detendr√°n la ejecuci√≥n)
   */
  public fatal(message: string, error?: Error | any, data?: any): void {
    const logData = {
      ...data,
      error: error ? this.errorSerializer(error) : undefined
    };
    this.log('fatal', message, logData);
  }
  
  /**
   * üéØ M√©todo principal de logging
   */
  private log(level: string, message: string, data?: any): void {
    const logData = {
      ...this.context,
      ...data,
      timestamp: new Date().toISOString()
    };
    
    // Llamar al m√©todo correspondiente de Pino
    (this.pinoLogger as any)[level](logData, message);
  }
  
  // üìä M√©todos especializados para acciones comunes
  
  /**
   * üåê Log de navegaci√≥n
   */
  public navigation(url: string, success: boolean, duration?: number): void {
    this.info(`Navegaci√≥n a: ${url}`, {
      action: 'navigation',
      url,
      success,
      duration
    });
  }
  
  /**
   * üéØ Log de b√∫squeda de elemento
   */
  public elementSearch(selector: string, found: boolean, duration?: number): void {
    const level = found ? 'debug' : 'warn';
    const message = found 
      ? `Elemento encontrado: ${selector}`
      : `Elemento NO encontrado: ${selector}`;
    
    this.log(level, message, {
      action: 'element_search',
      selector,
      found,
      duration
    });
  }
  
  /**
   * üñ±Ô∏è Log de acci√≥n sobre elemento
   */
  public elementAction(action: string, selector: string, success: boolean, details?: any): void {
    const level = success ? 'info' : 'error';
    const message = `${action} en elemento: ${selector}`;
    
    this.log(level, message, {
      action: `element_${action}`,
      selector,
      success,
      ...details
    });
  }
  
  /**
   * ‚úÖ Log de validaci√≥n/assertion
   */
  public assertion(description: string, passed: boolean, actual?: any, expected?: any): void {
    const level = passed ? 'info' : 'error';
    const status = passed ? 'PAS√ì' : 'FALL√ì';
    const message = `Validaci√≥n ${status}: ${description}`;
    
    this.log(level, message, {
      action: 'assertion',
      passed,
      actual,
      expected
    });
  }
  
  /**
   * üì∏ Log de screenshot
   */
  public screenshot(path: string, reason?: string): void {
    this.debug(`Screenshot guardado: ${path}`, {
      action: 'screenshot',
      path,
      reason
    });
  }
  
  /**
   * üé¨ Log de inicio de test
   */
  public testStart(testName: string, metadata?: any): void {
    this.info(`üé¨ INICIO TEST: ${testName}`, {
      action: 'test_start',
      testName,
      ...metadata
    });
  }
  
  /**
   * üèÅ Log de fin de test
   */
  public testEnd(testName: string, passed: boolean, duration?: number, metadata?: any): void {
    const emoji = passed ? '‚úÖ' : '‚ùå';
    const status = passed ? 'PAS√ì' : 'FALL√ì';
    
    this.info(`${emoji} FIN TEST: ${testName} - ${status}`, {
      action: 'test_end',
      testName,
      passed,
      duration,
      ...metadata
    });
  }
  
  /**
   * üìä Log de m√©tricas de rendimiento
   */
  public performance(metrics: any): void {
    this.info('üìä M√©tricas de rendimiento', {
      action: 'performance',
      metrics
    });
  }
  
  // üîß Serializers personalizados
  
  /**
   * üîÑ Serializer para errores
   */
  private errorSerializer(error: Error | FrameworkError | any): any {
    if (!error) return undefined;
    
    const serialized: any = {
      message: error.message || 'Unknown error',
      name: error.name || 'Error',
      stack: error.stack
    };
    
    // Si es un FrameworkError, agregar campos adicionales
    if (error instanceof FrameworkError || error.code) {
      serialized.code = error.code;
      serialized.details = error.details;
      serialized.screenshot = error.screenshot;
    }
    
    // Agregar propiedades adicionales
    Object.keys(error).forEach(key => {
      if (!['message', 'name', 'stack', 'code', 'details', 'screenshot'].includes(key)) {
        serialized[key] = (error as any)[key];
      }
    });
    
    return serialized;
  }
  
  /**
   * üîÑ Serializer para requests HTTP
   */
  private requestSerializer(req: any): any {
    if (!req) return undefined;
    
    return {
      method: req.method,
      url: req.url,
      headers: req.headers,
      query: req.query,
      params: req.params
    };
  }
  
  /**
   * üîÑ Serializer para responses HTTP
   */
  private responseSerializer(res: any): any {
    if (!res) return undefined;
    
    return {
      statusCode: res.statusCode || res.status,
      headers: res.headers,
      duration: res.duration
    };
  }
  
  /**
   * üéØ Crear un child logger con contexto adicional
   * √ötil para crear loggers espec√≠ficos para cada componente
   */
  public child(context: LogContext): Logger {
    const childLogger = new Logger(this.pinoLogger.bindings().name || 'child', {
      ...this.context,
      ...context
    });
    return childLogger;
  }
  
  /**
   * üìù M√©todo helper para loggear grupos de informaci√≥n
   */
  public group(title: string, data: Record<string, any>): void {
    const formattedData = Object.entries(data)
      .map(([key, value]) => `  ${key}: ${JSON.stringify(value)}`)
      .join('\n');
    
    this.info(`üìã ${title}\n${formattedData}`);
  }
  
  /**
   * üîÑ Flush: Asegurar que todos los logs se escriban
   */
  public async flush(): Promise<void> {
    return new Promise((resolve) => {
      this.pinoLogger.flush(() => {
        resolve();
      });
    });
  }
}